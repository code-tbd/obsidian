# 调度器
## 1. 调度循环
## 2. 调度触发
![调度触发时机](Pasted%20image%2020230801111252.png)  
**图 2-1 调度触发函数**  
- `exitsyscall0` 系统调用
- `goexit0` 协程结束
- `goschedImpl` 协作式调度
- `goyield_m` 和 `goschedImpl` 类似
- `mstart1` 线程开启
- `park_m` 挂起
- `preemptPark` 抢占式调度
### 2.1 park_m
```go
func park_m(gp *g) {
	casgstatus(gp, _Grunning, _Gwaiting)  
	dropg()  
	schedule()  
}
```
`park_m` 将 g 的状态从 `_Grunning` 切换为 `_Gwaiting`，进入等待，通过 `dropg` 将 g 和 m 互相解绑。需要注意的是 `park_m` 需要在 g0 上调用，因为 `dropg` 涉及到 g 的移动。
```go
func schedule() {
	mp := getg().m
}
```
调度函数需要通过 `getg().m` 来找到当前 g 所在的 m，已经解绑的 g 所属的 m 是空值。如果不在 g0 上调用而是直接在 curg 上调用，解绑之后就无法重新调度。
### 2.1.1 park_m 的常见调用时机
- 通道发送、通道接收时发生阻塞时
- 运行 g 终结器时
- gcworker 暂停工作时
- g 发生 panic 时
- 在信号量上阻塞时，比如各种常见的 Mutex 锁
- 在 select 语句中阻塞时
- 
## 3. 唤醒时机
### 3.1 goready